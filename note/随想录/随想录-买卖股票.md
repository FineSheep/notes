# 随想录-买卖股票

##  121. 买卖股票的最佳时机

[力扣题目链接(opens new window)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

### 思路

- ***分析影响利润的状态***

> 天数:第i天的股票
>
> 是否购买:购买和不购买
>
> 因此dp定义为二维数组

- ***dp定义***

> dp\[i][0]	:第i天持有股票所获得的最大利润
>
> dp\[i][1]	:第i天 不持有股票获得的最大利润

- ***递推公式***

**“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**

> 如果第i天持有股票即dp\[i][0]， 那么可以由两个状态推出来
>
> - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp\[i - 1][0]
> - 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]
>
> dp[i][0] = max(dp\[i - 1][0], -prices[i]);
>
> 如果第i天不持有股票即dp\[i][1]， 也可以由两个状态推出来
>
> - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp\[i - 1][1]
> - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp\[i - 1][0]
>
> 同样dp\[i][1]取最大的，dp[i][1] = max(dp\[i - 1][1], prices[i] + dp\[i - 1][0]);

- ***初始化***

> 那么dp\[0][0]表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以dp\[0][0]  =  -prices[0];
>
> dp\[0][1]表示第0天不持有股票，不持有股票那么现金就是0，所以dp\[0][1] = 0;

- ***遍历顺序***

> 从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。

### 题解

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        // dp[i][0]代表第i天持有股票的最大收益
        // dp[i][1]代表第i天不持有股票的最大收益
        for(int i=1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```

## 122.买卖股票的最佳时机II

[力扣题目链接(opens new window)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

示例 2:
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3:
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

提示：

- 1 <= prices.length <= 3 * 10 ^ 4
- 0 <= prices[i] <= 10 ^ 4

### 思路

本题和上一题区别在于**本题股票可以买卖多次了**（注意只有一只股票，所以再次购买前要出售掉之前的股票）

- ***dp含义***

> - dp\[i][0] 表示第i天持有股票所得现金。
> - dp\[i][1] 表示第i天不持有股票所得最多现金

- ***递推公式***

> 如果第i天持有股票即dp\[i][0]， 那么可以由两个状态推出来
>
> - 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp\[i - 1][0]
> - 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp\[i - 1][1] - prices[i]
>
> 如果第i天不持有股票即dp\[i][1]的情况， 依然可以由两个状态推出来
>
> - 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp\[i - 1][1]
> - 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp\[i - 1][0]

​		与上题区别:**推导dp\[i][0]的时候，第i天买入股票的情况**。

上题中,因为股票全程只能买卖一次，所以如果**买入股票**，那么第i天持有股票即dp\[i][0]一定就是 -prices[i]。

本题中,因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。
dp\[i - 1][1] - prices[i]

### 题解

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i=1;i<prices.length;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);//区别所在
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);
        }
        return dp[prices.length-1][1];
    }
}
```

## 123.买卖股票的最佳时机III

[力扣题目链接(opens new window)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。

示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。

示例 4： 输入：prices = [1] 输出：0

提示：

- 1 <= prices.length <= 10^5
- 0 <= prices[i] <= 10^5

### 思路

- 分析状态

> 1. 没有操作
> 2. 第一次买入
> 3. 第一次卖出
> 4. 第二次买入
> 5. 第二次卖出

- dp含义

> dp\[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp\[i][j]表示第i天状态j所剩最大现金。

- 递归公式

> 达到dp\[i][1]状态，有两个具体操作：
>
> - 操作一：第i天买入股票了，那么dp\[i][1] = dp\[i-1][0] - prices[i]
> - 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp\[i][1] = dp\[i - 1][1]
>
> dp\[i][1] = max(dp\[i-1][0] - prices[i], dp\[i - 1][1]);
>
> 同理dp\[i][2]也有两个操作：
>
> - 操作一：第i天卖出股票了，那么dp\[i][2] = dp\[i - 1][1] + prices[i]
> - 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp\[i - 1][2]
>
> 所以dp[i][2] = max(dp\[i - 1][1] + prices[i], dp\[i - 1][2])
>
> 同理可推出剩下状态部分：
>
> dp[i][3] = max(dp\[i - 1][3], dp\[i - 1][2] - prices[i]);
>
> dp[i][4] = max(dp\[i - 1][4], dp\[i - 1][3] + prices[i]);

### 题解

```java
class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][5];
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        //0：不操作 1：第一次持有   2：第一次不持有
        //3：第二次持有 4：第二次不持有
        for(int i=1;i<prices.length;i++){
            dp[i][0] = dp[i-1][0];
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i]);//第一次持有
            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]+prices[i]);//第一次不持有
            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]-prices[i]);//第二次持有
            dp[i][4] = Math.max(dp[i-1][4],dp[i-1][3]+prices[i]);
        }

        return dp[prices.length-1][4];
    }
}
```

## 188.买卖股票的最佳时机IV

[力扣题目链接(opens new window)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。

示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

提示：

- 0 <= k <= 100
- 0 <= prices.length <= 1000
- 0 <= prices[i] <= 1000

### 思路

> j的状态表示为：
>
> - 0 表示不操作
> - 1 第一次买入
> - 2 第一次卖出
> - 3 第二次买入
> - 4 第二次卖出
> - .....
>
> **除了0以外，偶数就是卖出，奇数就是买入**。
>
> 题目要求是至多有K笔交易，那么j的范围就定义为 2 * k + 1 就可以了。

### 题解

```java
class Solution {
    public int maxProfit(int k, int[] prices) {

        int[][] dp = new int[prices.length][2*k+1];
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for(int i=1;i<prices.length;i++){
            for (int j = 0; j < 2 * k - 1; j += 2){
                dp[i][j+1] = Math.max(dp[i-1][j+1],dp[i-1][j]-prices[i]);
                dp[i][j+2] = Math.max(dp[i-1][j+2],dp[i-1][j+1]+prices[i]);
            }

        }
        return dp[prices.length-1][2*k];
    }
}
```

## 309.最佳买卖股票时机含冷冻期

[力扣题目链接(opens new window)](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

### 思路

> - 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
> - 卖出股票状态，这里就有两种卖出股票状态
>   - 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
>   - 状态三：今天卖出了股票
> - 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

### 题解

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        int[][] dp = new int[len][3];
        dp[0][0] = 0; // 当天结束时无股票（不包含冷冻期）
        dp[0][1] = -prices[0]; // 当天结束时手里有股票
        dp[0][2] = 0; // 当天为冷冻期
        for(int i = 1 ; i < len ;i++){
            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][2]);
            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0] - prices[i]);
            dp[i][2] = dp[i-1][1] + prices[i]; 
        }
        return Math.max(dp[len-1][0],dp[len-1][2]);
    }   
}
```