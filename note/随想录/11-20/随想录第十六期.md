# éšæƒ³å½•ç¬¬åå…­æœŸ

## 513.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

[åŠ›æ‰£é¢˜ç›®é“¾æ¥(opens new window)](https://leetcode.cn/problems/find-bottom-left-tree-value/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåœ¨æ ‘çš„æœ€åä¸€è¡Œæ‰¾åˆ°æœ€å·¦è¾¹çš„å€¼ã€‚

ç¤ºä¾‹ 1:

![513.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼](https://img-blog.csdnimg.cn/20210204152956836.png)

ç¤ºä¾‹ 2:

![513.æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼1](https://img-blog.csdnimg.cn/20210204153017586.png)

### æ€è·¯

> 1. å±‚æ¬¡éå†
> 2. è®°å½•æ¯ä¸€å±‚ç¬¬ä¸€ä¸ªäººæ•°

### é¢˜è§£

```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    public int findBottomLeftValue(TreeNode root) {
        
        queue.add(root);
        int result =0;
        while(!queue.isEmpty()){
          int size = queue.size();
          for(int i=1;i<=size;i++){
            TreeNode node=  queue.poll();
              if(i==1){
                result = node.val;
              } 
          if(node.left!=null){
              queue.add(node.left);
          }
          if(node.right!=null){
              queue.add(node.right);
          }
          }

        }
        return result;
    }
}
```

## 112. è·¯å¾„æ€»å’Œ

[åŠ›æ‰£é¢˜ç›®é“¾æ¥(opens new window)](https://leetcode.cn/problems/path-sum/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ªç›®æ ‡å’Œï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’Œã€‚

è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

ç¤ºä¾‹: ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ sum = 22ï¼Œ

![112.è·¯å¾„æ€»å’Œ1](https://img-blog.csdnimg.cn/20210203160355234.png)

è¿”å› true, å› ä¸ºå­˜åœ¨ç›®æ ‡å’Œä¸º 22 çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ 5->4->11->2ã€‚

## æ€è·¯

> 1. æ ¹æ®å¶å­èŠ‚ç‚¹è®°å½•å’Œ
>
>    (åˆ¤æ–­å¶å­ğŸ¥¥èŠ‚ç‚¹:æ ¹æ®å½“å‰èŠ‚ç‚¹çš„å·¦å³å­æ ‘æ˜¯å¦ä¸ºç©º)
>
> 2. å›æº¯è®°å½•

å¦‚å›¾æ‰€ç¤ºï¼š

![112.è·¯å¾„æ€»å’Œ](https://img-blog.csdnimg.cn/2021020316051216.png)

## é¢˜è§£

```java
class Solution {
    int sum =0;
    boolean result ;
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root==null) return result;
        sum+=root.val;
        back(root,targetSum);
        return result;
    }

    public void back(TreeNode root, int targetSum){
        if(root.left==null && root.right==null){
            System.out.println(sum);
            if(sum==targetSum){
                result=true;
            }
            return;
        }
        if(root.left!=null){
            sum+=root.left.val;
            back(root.left,targetSum);
            sum-=root.left.val;
        }
        if(root.right!=null){
            sum+=root.right.val;
            back(root.right,targetSum);
            sum-=root.right.val;
        }
    }
}
```

## 113. è·¯å¾„æ€»å’Œii

[åŠ›æ‰£é¢˜ç›®é“¾æ¥(opens new window)](https://leetcode.cn/problems/path-sum-ii/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ªç›®æ ‡å’Œï¼Œæ‰¾åˆ°æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚

è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

ç¤ºä¾‹: ç»™å®šå¦‚ä¸‹äºŒå‰æ ‘ï¼Œä»¥åŠç›®æ ‡å’Œ sum = 22ï¼Œ

![113.è·¯å¾„æ€»å’Œii1.png](https://img-blog.csdnimg.cn/20210203160854654.png)

### æ€è·¯

> å›æº¯çš„åŒæ—¶è®°å½•è·¯å¾„

### é¢˜è§£

```java
class Solution {
    int sum =0;
    List<List<Integer>> list = new LinkedList<>();
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        if(root==null) return list;
        sum+=root.val;
        LinkedList<Integer> res = new LinkedList<>();
        res.add(root.val);
        back(root,targetSum,res);
        return list;

    }
      public void back(TreeNode root, int targetSum,LinkedList res){
         
        if(root.left==null && root.right==null){
            List<Integer> res1 = new LinkedList<>(res);
            if(sum==targetSum){
                list.add(res1);
            }
            return;
        }
        
        if(root.left!=null){
            res.add(root.left.val);
            sum+=root.left.val;
            back(root.left,targetSum,res);
            sum-=root.left.val;
            res.removeLast();
        }
        if(root.right!=null){
            sum+=root.right.val;
            res.add(root.right.val);
            back(root.right,targetSum,res);
            sum-=root.right.val;
            res.removeLast();
        }
    }
}
```

## 106.ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

[åŠ›æ‰£é¢˜ç›®é“¾æ¥(opens new window)](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

æ ¹æ®ä¸€æ£µæ ‘çš„ä¸­åºéå†ä¸ååºéå†æ„é€ äºŒå‰æ ‘ã€‚

æ³¨æ„: ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚

ä¾‹å¦‚ï¼Œç»™å‡º

ä¸­åºéå† inorder = [9,3,15,20,7] ååºéå† postorder = [9,15,7,20,3] è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

![106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘1](https://img-blog.csdnimg.cn/20210203154316774.png)

## æ€è·¯

> [ä¸œå“¥å¸¦ä½ åˆ·äºŒå‰æ ‘ï¼ˆæ„é€ ç¯‡ï¼‰ :: labuladongçš„ç®—æ³•å°æŠ„](https://labuladong.github.io/algo/2/21/38/)

> å‡½æ•°å®šä¹‰:
>
>    **build å‡½æ•°çš„å®šä¹‰ï¼š**    **ååºéå†æ•°ç»„ä¸º postorder[postStart..postEnd]ï¼Œ**    **ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ**    **æ„é€ äºŒå‰æ ‘ï¼Œè¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹**  
>
> é€€å‡ºæ¡ä»¶:ç´¢å¼•æ— æ•ˆ
>
> æ„é€ :æ„é€ æ ¹èŠ‚ç‚¹,é€’å½’æ„é€ å·¦å³å­æ ‘(å¯¹æ•°ç»„è¿›è¡Œåˆ‡å‰²)

ç°åœ¨ `postoder` å’Œ `inorder` å¯¹åº”çš„çŠ¶æ€å¦‚ä¸‹ï¼š

[![img](https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/6.jpeg)](https://labuladong.github.io/algo/images/äºŒå‰æ ‘ç³»åˆ—2/6.jpeg)

### é¢˜è§£

```java
class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
 return build(inorder, 0, inorder.length - 1,
                postorder, 0, postorder.length - 1);
    }

    public TreeNode build(int[] inorder,int instart, int inend,
                            int[] postorder,int postart,int poend){
        if(instart> inend || postart>poend) return null;
        int root = postorder[poend];
        int index=-1;
        for(int i=0;i<inorder.length;i++){
            if(inorder[i]==root){
                index=i;
            }
        }
            int size = index-instart;
            TreeNode node = new TreeNode(root);
            node.left = build(inorder,instart,index-1,
                                postorder,postart,postart+size-1);
            node.right = build(inorder,index+1,inend,
                                postorder,postart+size,poend-1);

            return node;
    }
}
```

## 105.ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

[åŠ›æ‰£é¢˜ç›®é“¾æ¥(opens new window)](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

æ ¹æ®ä¸€æ£µæ ‘çš„å‰åºéå†ä¸ä¸­åºéå†æ„é€ äºŒå‰æ ‘ã€‚

æ³¨æ„: ä½ å¯ä»¥å‡è®¾æ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ã€‚

ä¾‹å¦‚ï¼Œç»™å‡º

å‰åºéå† preorder = [3,9,20,15,7] ä¸­åºéå† inorder = [9,3,15,20,7] è¿”å›å¦‚ä¸‹çš„äºŒå‰æ ‘ï¼š

![105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘](https://img-blog.csdnimg.cn/20210203154626672.png)

### æ€è·¯

[![img](https://labuladong.github.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/4.jpeg)](https://labuladong.github.io/algo/images/äºŒå‰æ ‘ç³»åˆ—2/4.jpeg)

### é¢˜è§£

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {

        return build(preorder, 0, preorder.length-1,
                inorder, 0, inorder.length-1);
    }

    public TreeNode build(int[] preorder, int preStart, int preEnd,
                          int[] inorder, int inStart, int inEnd) {
        if (preStart > preEnd) return null;
        int root = preorder[preStart];
        int index = -1;
        for (int i = 0; i < inorder.length; i++) {
            if (root == inorder[i]) {
                index = i;
            }
        }
        int leftSize = index - inStart;

        TreeNode node = new TreeNode(root);
        node.left = build(preorder,preStart+1,preStart+leftSize,
                inorder,inStart,index-1);

        node.right = build(preorder,preStart+leftSize+1,preEnd,
                inorder,index+1,inEnd);

        return node;

    }
}

```
